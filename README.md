# about-development
assignment

**Methodology) Agile VS Waterfall**
https://www.ciokorea.com/news/166830
방법론은 프로잭트 유형, 팀 구조, 역량 등의 요인에 따라 유형이 달라진다.

애자일: 짧고 점진적인 개발 주기로 구성된 프로젝트 관리 방법론(Sprint)
각 주기는 제품이나 서비스 개발을 지속적으로 향상시키는데 초점
애자일 선언(Agile Menifesto): 4가지 기본 가치 + 12가지 원칙
  1. 개인과 개인 간의 상호작용이 프로세스 및 툴보다 우선
2. 작동하는 SW가 포괄적인 문서보다 우선
3. 고객과의 협업이 계약 협상보다 우선
4. 변화에 대응하는 것이 계획을 따르는 것보다 우선
반복적이며 사람 중심적 개발 방식
애자일 프로세스
1. 계획: 고객과 주요 이해관계자들이 함께 프로젝트 개념화, 브레인스토밍, 정의, 우선순위설정, 필요 자원, 예산 책정 논의. 그 후 승인 및 실행하는 작업.
2. 설계: 사용자 경험 전문가가 스크럼 마스터, 클라이언트, 제품팀 그리고 기타 주요 이해관계자와 협력해 제품의 모양새와 여타 요소들을 결정.
3. 개발: 개발팀은 이 단계에서 ‘스프린트’라고 불리는 여러 반복 작업을 거치며 고객 요구사항에 맞는 제품을 개발.
4. 테스팅: 이 단계에서는 제품이 고객 요구사항을 충족하는지 확인. 만약 결함이 발견되면 해당 제품을 개발 단계로 보내 결함을 수정하고 다시 테스트한다. 이 단계는 제품이 고객 요구사항이나 목표를 충족할 때까지 지속.
5. 배포: 모든 단계가 완료되면 최종 제품을 클라이언트에게 전달.
6. 피드백: 팀이 전체 개발 프로세스를 회고하며 제품이나 팀의 성과를 개선하는 방법을 검토.

결론) 애자일 팀은 고객 중심적이고, 환경 변화에 잘 적응하며, 악조건에서도 제품을 출시할 수 있어야 한다. 따라서 팀과 고객 모두 강력한 팀워크와 책임감이 있는 인력 필요. 진행 속도가 빠른 개발 환경에서 좋은 결과물이 나온다.

워터폴: 선형적 개발 과정. 프로젝트의 시작부터 최종까지 특정 순서에 따라 이뤄진다.
프로세스
1. 요구사항 수집과 분석: 프로젝트에 사용될 기능적, 시스템적 또는 기술적 사양 정보를 클라이언트와 주요 이해관계자로부터 수집한다.
2. 설계: 사용자 경험 전문가는 고객, 제품팀 및 기타 주요 이해관계자와 함께 제품의 모양새와 여타 요소들을 결정.
3. 테스팅: 성능, 시스템 및 사용자 승인 테스팅을 수행, 제품이 요구사항을 충족하는지 확인. 만약 결함이나 버그가 발견되면 제품이 전달되기 전에 해결된다.
4. 프로젝트 최종 결과물 전달: 프로젝트를 착수할 때 확정했던 사양을 제품이 충족하면 클라이언트에게 전달.
5. 유지보수: 클라이언트는 제품을 전달받은 후 추가적인 스코프 변경을 요청할 수 있다. 프로젝트 비용과 시간은 추가될 수 있다.

결론) 워터폴 팀은 프로세스와 절차가 잘 정착된 환경에서 업무를 능숙하게 처리. 이외적인 상황이 없을 때 능률이 오른다. 체계적이고 사전 합의된 요구사항을 충족하는데 초점. 워터폴 팀은 다양한 영역의 사람들과 능숙하게 협업할 수 있어야하며 정책이나 엄격한 가이드라인도 잘 준수한다.

**The Twelve-Factor App**
WebApp / SaaS
최근 소프트웨어들은 서비스 형태로 제공되는 것이 일반적
12-Factor App Methodology
-설정 자동화를 위한 절차(declarative)를 체계화하여 새로운 개발자가
프로젝트에 참여하는데 드는 시간과 비용 최소화
-OS에 따라 달라지는 부분 명확히, 실행 환경 사이의 이식성 극대화
-클라우드 플랫폼 배포에 적합, 서버와 시스템의 관리 필요 X
-개발 환경과 운영 환경의 차이 최소화, 민첩성 극대화를 위해 지속적 배포 가능
-툴, 아키텍처, 개발 방식을 크게 바꾸지 않고 확장 가능(scale up)

시간이 지나면서 앱의 유기적 성장, 앱 코드베이스에서 작업하는 개발자 간 협업, 시간이 지나며 망가지는 SW 유지비용을 줄이는 방법에 집중 -> 이상적인 앱 개발 방법 발견

1. 코드 베이스 : 버전 관리되는 하나의 코드베이스와 다양한 배포
2. 종속성: 명시적으로 선언되고 분리된 종속성
3. 설정: 환경에 저장된 설정
4. 백엔드 서비스: 백엔드 서비스를 연결된 리소스로 취급
5. 빌드, 릴리즈, 실행: 철저하게 분리된 빌드와 실행 단계
6. 프로세스: 앱을 하나 혹은 여러개의 무상태(stateless) 프로세스로 실행
7. 포트 바인딩: 포트바인딩을 사용해서 서비스를 공개함
8. 동시성(concurrency): 프로세스 모델을 사용한 확장
9. 폐기 가능(disposability): 빠른 시작과 그레이스풀 셧다운을 통한 안정성 극대화
10. 개발/프로덕션 환경 일치: 개발, 스테이징, 프로덕션 환경을 최대한 비슷하게 유지
11. 로그: 로그를 이벤트 스트림으로 취급
12. admin 프로세스: admin/maintenance 작업을 일회성 프로세스 실행

**Restful API) URI Pattern**
API) 사용자 또는 클라이언트, 그리고 사용자와 클라이언트가 얻으려 하는 리소스 사이의 조정자. 조직이 보안 및 제어를 유지관리하면서 리소스와 정보를 공유할 수 있는 방법. 리소스 검색 방법 또는 리소스의 출처에 대한 지식 없이도 사용이 가능

Representational State Transfer Application Programming Interface
Rest 아키텍처 제약조건을 준수하는 API, App SW를 구축하고 통합하는 정의 및 프로토콜 세트

REST API 구성
1. 자원(Resource): URI
2. 행위(Verb): HTTP Method
3. 표현(Representations)

REST 특징
1. Uniform(유니폼 인터페이스): URI로 지정한 리소스에 대한 조작을 통일되고 한정적인 인터페이스로 수행하는 아키텍처 스타일
2. Stateless(무상태성): 작업을 위한 상태정보를 따로 저장하고 관리하지 않는다. 세션 정보나 쿠키 정보를 별도로 저장하고 관리하지 않기 때문에 API서버는 들어오는 요청을 단순 처리만 하면 된다. 따라서 서비스의 자유도가 높아지고 서버에서 불필요한 정보를 관리하지 않기에 구현이 단순
3. Cacheable(캐시 가능): HTTP 기존 웹 표준을 그대로 사용, 웹에서 사용하는 기존 인프라 그대로 활용 가능. 따라서 HTTP의 캐싱 기능 적용 가능. -> Last-Modified 태그나 E-Tag 이용
4. Self-Descriptiveness(자체 표현 구조): REST API 메시지만 보고도 쉽게 이해할 수 있는 자체 표현 구조
5. Client-Server 구조: REST 서버는 API 제공, 클라이언트는 사용자 인증이나 컨텍스트 등 직접 관리하는 구조로 각각의 역할이 구분되기에 C-S 개발 내용이 명확, 의존성이 줄어듦
6. 계층형 구조: 보안, 로드 밸런싱,  암호화 계층을 추가해 구조상의 유연성을 둘 수 있고 PROXY, 게이트웨이 같은 네트워크 기반의 중간매체 사용 가능

REST API 디자인 가이드
1. URI는 정보의 자원을 표현해야 함
2. 자원에 대한 행위는 HTTP Method(get, post, put, delete)로 표현
    1. post: 해당 URI를 요청하면 리소스 생성(회원 추가)
    2. get: 해당 리소스 조회, 해당 document에 대한 자세한 정보를 가져온다.(회원 정보)
    3. put: 해당 리소스 수정
    4. delete: 해당 리소스 삭제
URI 설계 시 주의점
1. 슬래시(/) 구분자는 계층 관계를 나타낼 때 사용
2. URI 마지막 문자로 /를 포함하지 않는다.
3. 하이픈(-)은 URI 가독성을 높이는데 사용
4. 밑줄(_)은 URI에 사용하지 않는다
5. URI 경로에는 소문자가 적합
6. 파일 확장자는 URI에 포함시키지 않는다.(Accept Header 사용)
 	-http://restapi.example.com/members/soccer/345/photo.jpg (X)
	-GET / members/soccer/345/photo HTTP/1.1 Host: 				restapi.example.com Accept: image/jpg (O)
7. URI는 동사보다는 명사 사용
8. 행위를 포함하지 않는다.
	-Bad Example http://khj93.com/delete-post/1  
	-Good Example  http://khj93.com/post/1  

모든 CRUD 기능을 POST로 처리 하는 API 혹은 URI 규칙을 올바르게 지키지 않은 API는 설계 규칙을 올바르게 지키지 못한 시스템이며 REST API를 사용하였지만 RESTful 하지 못한 시스템이다.

**Transaction) ACID**
https://victorydntmd.tistory.com/129
트랜잭션이란 질의(query)를 하나의 묶음 처리해서 만약 중간에 실행이 중단됐을 경우, 처음부터 다시 실행하는 Rollback을 수행하고, 오류없이 실행을 마치면 commit을 하는 실행 단위를 의미합니다.
즉, 한 번 질의가 실행되면 질의가 모두 수행되거나 모두 수행되지 않는 작업수행의 논리적 단위입니다.

트랜잭션 사용 이유
트랜잭션은 DB 서버에 여러 개의 클라이언트가 동시에 액세스 하거나 응용프로그램이 갱신을 처리하는 과정에서 중단될 수 있는 경우 등 데이터 부정합을 방지하고자 할 때 사용합니다.
부정합이 발생하지 않으려면 프로세스를 병렬로 처리하지 않도록 하여 한 번에 하나의 프로세스만 처리하도록 하면 되는데, 이는 효율이 너무 떨어집니다.
즉, 병렬로 처리할 수 밖에 없는 현실적인 상황으로 인해 부정합을 방지하고자 트랜잭션을 사용하는 것입니다. 트랜잭션에서 중요한 것은 스케줄 관리입니다. 스케줄을 잘못 짜게 되면, 데드락에 빠지게 된다.
* 원자성 ( Atomicity )
    * 트랜잭션의 작업이 부분적으로 실행되거나 중단되지 않는 것을 보장
    * All or Noting의 개념으로서 작업 단위를 일부분만 실행하지 않는다
* 일관성 ( Consistency )
    * 트랜잭션이 성공적으로 완료되면 일관적인 DB상태를 유지하는 것
    * 여기서 말하는 일관성이란, 송금 예제에서 금액의 데이터 타입이 정수형(integer)인데, 갑자기 문자열(string)이 되지 않는 것을 말합니다.
        * 즉, 송금 전후 모두 금액의 데이터 타입은 정수형이여야 한다는 것
* 격리성 ( Isolation )
    * 트랜잭션 수행시 다른 트랜잭션의 작업이 끼어들지 못하도록 보장
    * 트랜잭션끼리는 서로를 간섭할 수 없습니다.
* 지속성 ( Durability )
    * 성공적으로 수행된 트랜잭션은 영원히 반영이 되는 것
    * commit을 하면 현재 상태는 영원히 보장
    * 트랜잭션에 대한 로그가 남는다. 즉, 실행 오류가 발생하더라도, 해당 기록은 영구적

특성 보장
1. 원자성 보장: 수행하고 있는 트랜잭션에 의해 변경된 내역을 유지하면서, 이전에 commit된 상태를 임시 영역에 따로 저장함으로써 보장
2. 일관성 보장: 트랜잭션 수행 전, 후에 데이터 모델의 모든 제약 조건(기본키, 외래키, 도메인, 도메인 제약조건 등)을 만족하는 것을 통해 보장
3. 고립성 보장: OS의 세마포어(semaphore)와 비슷한 개념으로 lock & excute  unlock을 통해 고립성을 보장, 즉, 데이터를 읽거나 쓸 때는 문을 잠궈서 다른 트랜잭션이 접근하지 못하도록 고립성을 보장하고, 수행을 마치면 unlock을 통해 데이터를 다른 트랜잭션이 접근할 수 있도록 허용 -> 갱신분실, 오손판독, 반복불가능, 팬텀문제 방지
