# about-development
assignment

Methodology) Agile VS Waterfall
https://www.ciokorea.com/news/166830
방법론은 프로잭트 유형, 팀 구조, 역량 등의 요인에 따라 유형이 달라진다.

애자일: 짧고 점진적인 개발 주기로 구성된 프로젝트 관리 방법론(Sprint)
각 주기는 제품이나 서비스 개발을 지속적으로 향상시키는데 초점
애자일 선언(Agile Menifesto): 4가지 기본 가치 + 12가지 원칙
  1. 개인과 개인 간의 상호작용이 프로세스 및 툴보다 우선
2. 작동하는 SW가 포괄적인 문서보다 우선
3. 고객과의 협업이 계약 협상보다 우선
4. 변화에 대응하는 것이 계획을 따르는 것보다 우선
반복적이며 사람 중심적 개발 방식
애자일 프로세스
1. 계획: 고객과 주요 이해관계자들이 함께 프로젝트 개념화, 브레인스토밍, 정의, 우선순위설정, 필요 자원, 예산 책정 논의. 그 후 승인 및 실행하는 작업.
2. 설계: 사용자 경험 전문가가 스크럼 마스터, 클라이언트, 제품팀 그리고 기타 주요 이해관계자와 협력해 제품의 모양새와 여타 요소들을 결정.
3. 개발: 개발팀은 이 단계에서 ‘스프린트’라고 불리는 여러 반복 작업을 거치며 고객 요구사항에 맞는 제품을 개발.
4. 테스팅: 이 단계에서는 제품이 고객 요구사항을 충족하는지 확인. 만약 결함이 발견되면 해당 제품을 개발 단계로 보내 결함을 수정하고 다시 테스트한다. 이 단계는 제품이 고객 요구사항이나 목표를 충족할 때까지 지속.
5. 배포: 모든 단계가 완료되면 최종 제품을 클라이언트에게 전달.
6. 피드백: 팀이 전체 개발 프로세스를 회고하며 제품이나 팀의 성과를 개선하는 방법을 검토.

결론) 애자일 팀은 고객 중심적이고, 환경 변화에 잘 적응하며, 악조건에서도 제품을 출시할 수 있어야 한다. 따라서 팀과 고객 모두 강력한 팀워크와 책임감이 있는 인력 필요. 진행 속도가 빠른 개발 환경에서 좋은 결과물이 나온다.

워터폴: 선형적 개발 과정. 프로젝트의 시작부터 최종까지 특정 순서에 따라 이뤄진다.
프로세스
1. 요구사항 수집과 분석: 프로젝트에 사용될 기능적, 시스템적 또는 기술적 사양 정보를 클라이언트와 주요 이해관계자로부터 수집한다.
2. 설계: 사용자 경험 전문가는 고객, 제품팀 및 기타 주요 이해관계자와 함께 제품의 모양새와 여타 요소들을 결정.
3. 테스팅: 성능, 시스템 및 사용자 승인 테스팅을 수행, 제품이 요구사항을 충족하는지 확인. 만약 결함이나 버그가 발견되면 제품이 전달되기 전에 해결된다.
4. 프로젝트 최종 결과물 전달: 프로젝트를 착수할 때 확정했던 사양을 제품이 충족하면 클라이언트에게 전달.
5. 유지보수: 클라이언트는 제품을 전달받은 후 추가적인 스코프 변경을 요청할 수 있다. 프로젝트 비용과 시간은 추가될 수 있다.

결론) 워터폴 팀은 프로세스와 절차가 잘 정착된 환경에서 업무를 능숙하게 처리. 이외적인 상황이 없을 때 능률이 오른다. 체계적이고 사전 합의된 요구사항을 충족하는데 초점. 워터폴 팀은 다양한 영역의 사람들과 능숙하게 협업할 수 있어야하며 정책이나 엄격한 가이드라인도 잘 준수한다.

The Twelve-Factor App
WebApp / SaaS
최근 소프트웨어들은 서비스 형태로 제공되는 것이 일반적
12-Factor App Methodology
-설정 자동화를 위한 절차(declarative)를 체계화하여 새로운 개발자가
프로젝트에 참여하는데 드는 시간과 비용 최소화
-OS에 따라 달라지는 부분 명확히, 실행 환경 사이의 이식성 극대화
-클라우드 플랫폼 배포에 적합, 서버와 시스템의 관리 필요 X
-개발 환경과 운영 환경의 차이 최소화, 민첩성 극대화를 위해 지속적 배포 가능
-툴, 아키텍처, 개발 방식을 크게 바꾸지 않고 확장 가능(scale up)

시간이 지나면서 앱의 유기적 성장, 앱 코드베이스에서 작업하는 개발자 간 협업, 시간이 지나며 망가지는 SW 유지비용을 줄이는 방법에 집중 -> 이상적인 앱 개발 방법 발견

1. 코드 베이스 : 버전 관리되는 하나의 코드베이스와 다양한 배포
2. 종속성: 명시적으로 선언되고 분리된 종속성
3. 설정: 환경에 저장된 설정
4. 백엔드 서비스: 백엔드 서비스를 연결된 리소스로 취급
5. 빌드, 릴리즈, 실행: 철저하게 분리된 빌드와 실행 단계
6. 프로세스: 앱을 하나 혹은 여러개의 무상태(stateless) 프로세스로 실행
7. 포트 바인딩: 포트바인딩을 사용해서 서비스를 공개함
8. 동시성(concurrency): 프로세스 모델을 사용한 확장
9. 폐기 가능(disposability): 빠른 시작과 그레이스풀 셧다운을 통한 안정성 극대화
10. 개발/프로덕션 환경 일치: 개발, 스테이징, 프로덕션 환경을 최대한 비슷하게 유지
11. 로그: 로그를 이벤트 스트림으로 취급
12. admin 프로세스: admin/maintenance 작업을 일회성 프로세스 실행

Restful API) URL Pattern


Transaction) ACID
https://victorydntmd.tistory.com/129
트랜잭션이란 질의(query)를 하나의 묶음 처리해서 만약 중간에 실행이 중단됐을 경우, 처음부터 다시 실행하는 Rollback을 수행하고, 오류없이 실행을 마치면 commit을 하는 실행 단위를 의미합니다.
즉, 한 번 질의가 실행되면 질의가 모두 수행되거나 모두 수행되지 않는 작업수행의 논리적 단위입니다.

트랜잭션 사용 이유
트랜잭션은 DB 서버에 여러 개의 클라이언트가 동시에 액세스 하거나 응용프로그램이 갱신을 처리하는 과정에서 중단될 수 있는 경우 등 데이터 부정합을 방지하고자 할 때 사용합니다.
부정합이 발생하지 않으려면 프로세스를 병렬로 처리하지 않도록 하여 한 번에 하나의 프로세스만 처리하도록 하면 되는데, 이는 효율이 너무 떨어집니다.
즉, 병렬로 처리할 수 밖에 없는 현실적인 상황으로 인해 부정합을 방지하고자 트랜잭션을 사용하는 것입니다. 트랜잭션에서 중요한 것은 스케줄 관리입니다. 스케줄을 잘못 짜게 되면, 데드락에 빠지게 된다.
* 원자성 ( Atomicity )
    * 트랜잭션의 작업이 부분적으로 실행되거나 중단되지 않는 것을 보장
    * All or Noting의 개념으로서 작업 단위를 일부분만 실행하지 않는다
* 일관성 ( Consistency )
    * 트랜잭션이 성공적으로 완료되면 일관적인 DB상태를 유지하는 것
    * 여기서 말하는 일관성이란, 송금 예제에서 금액의 데이터 타입이 정수형(integer)인데, 갑자기 문자열(string)이 되지 않는 것을 말합니다.
        * 즉, 송금 전후 모두 금액의 데이터 타입은 정수형이여야 한다는 것
* 격리성 ( Isolation )
    * 트랜잭션 수행시 다른 트랜잭션의 작업이 끼어들지 못하도록 보장
    * 트랜잭션끼리는 서로를 간섭할 수 없습니다.
* 지속성 ( Durability )
    * 성공적으로 수행된 트랜잭션은 영원히 반영이 되는 것
    * commit을 하면 현재 상태는 영원히 보장
    * 트랜잭션에 대한 로그가 남는다. 즉, 실행 오류가 발생하더라도, 해당 기록은 영구적

특성 보장
1. 원자성 보장: 수행하고 있는 트랜잭션에 의해 변경된 내역을 유지하면서, 이전에 commit된 상태를 임시 영역에 따로 저장함으로써 보장
2. 일관성 보장: 트랜잭션 수행 전, 후에 데이터 모델의 모든 제약 조건(기본키, 외래키, 도메인, 도메인 제약조건 등)을 만족하는 것을 통해 보장
3. 고립성 보장: OS의 세마포어(semaphore)와 비슷한 개념으로 lock & excute  unlock을 통해 고립성을 보장, 즉, 데이터를 읽거나 쓸 때는 문을 잠궈서 다른 트랜잭션이 접근하지 못하도록 고립성을 보장하고, 수행을 마치면 unlock을 통해 데이터를 다른 트랜잭션이 접근할 수 있도록 허용 -> 갱신분실, 오손판독, 반복불가능, 팬텀문제 방지
